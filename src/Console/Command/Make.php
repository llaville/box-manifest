<?php declare(strict_types=1);
/**
 * This file is part of the BoxManifest package.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace Bartlett\BoxManifest\Console\Command;

use Bartlett\BoxManifest\Composer\ManifestOptions;
use Bartlett\BoxManifest\Console\Logger;
use Bartlett\BoxManifest\Helper\BoxHelper;
use Bartlett\BoxManifest\Helper\ManifestFormat;
use Bartlett\BoxManifest\Pipeline\AbstractStage;
use Bartlett\BoxManifest\Pipeline\BuildStage;
use Bartlett\BoxManifest\Pipeline\CompileStage;
use Bartlett\BoxManifest\Pipeline\ConfigureStage;
use Bartlett\BoxManifest\Pipeline\StageInterface;
use Bartlett\BoxManifest\Pipeline\StubStage;
use Bartlett\BoxManifest\Pipeline\InterruptibleTimedProcessor;

use CycloneDX\Core\Spec\Version;

use Fidry\Console\IO;

use League\Pipeline\FingersCrossedProcessor;
use League\Pipeline\PipelineBuilder;

use Psr\Log\LoggerInterface;

use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Helper\DebugFormatterHelper;
use Symfony\Component\Console\Helper\Helper;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputDefinition;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\NullOutput;
use Symfony\Component\Console\Output\OutputInterface;

use InvalidArgumentException;
use Throwable;
use UnexpectedValueException;
use function array_unique;
use function chdir;
use function class_exists;
use function count;
use function getcwd;
use function implode;
use function is_file;
use function is_string;
use function microtime;
use function realpath;
use function sprintf;
use function uniqid;

/**
 * @author Laurent Laville
 * @since Release 4.0.0
 */
final class Make extends Command
{
    public const NAME = 'make';

    private const HELP = <<<'HELP'
        The <info>%command.name%</info> command will create a full automated execution patterns of your manifest build process.
        HELP;

    protected function configure(): void
    {
        $options = [
            new InputArgument(
                'stages',
                InputArgument::REQUIRED | InputArgument::IS_ARRAY,
                'Stages to proceed in your pipeline',
            ),
            new InputOption(
                ManifestOptions::BOOTSTRAP_OPTION,
                'b',
                InputOption::VALUE_REQUIRED,
                'A PHP script that is included before execution',
            ),
            new InputOption(
                ManifestOptions::FORMAT_OPTION,
                'f',
                InputOption::VALUE_REQUIRED,
                'Format of the output: <comment>' . implode(', ', array_column(ManifestFormat::cases(), 'value')) . '</comment>',
                ManifestFormat::auto->value
            ),
            new InputOption(
                ManifestOptions::SBOM_SPEC_OPTION,
                's',
                InputOption::VALUE_REQUIRED,
                'SBOM specification version: <comment>' . implode(', ', array_column(Version::cases(), 'value')) . '</comment>',
                Version::v1dot6->value
            ),
            new InputOption(
                ManifestOptions::OUTPUT_OPTION,
                'o',
                InputOption::VALUE_REQUIRED,
                'Write results to file (<comment>default to standard output</comment>)'
            ),
            new InputOption(
                ManifestOptions::OUTPUT_STUB_OPTION,
                null,
                InputOption::VALUE_REQUIRED,
                'Write stub PHP code to file (<comment>default to standard output</comment>)'
            ),
            new InputOption(
                ManifestOptions::OUTPUT_CONF_OPTION,
                null,
                InputOption::VALUE_REQUIRED,
                'Write BOX configuration to file (<comment>default to standard output</comment>)'
            ),
            new InputOption(
                ManifestOptions::TEMPLATE_OPTION,
                't',
                InputOption::VALUE_REQUIRED,
                'PHP template file to customize the stub'
            ),
            new InputOption(
                ManifestOptions::RESOURCE_OPTION,
                'r',
                InputOption::VALUE_REQUIRED | InputOption::VALUE_IS_ARRAY,
                'File(s) generated by the box-manifest binary command'
            ),
            new InputOption(
                ManifestOptions::RESOURCE_DIR_OPTION,
                null,
                InputOption::VALUE_REQUIRED,
                'Directory where to store your manifest files into the PHP Archive',
                AbstractStage::BOX_MANIFESTS_DIR
            ),
            new InputOption(
                ManifestOptions::IMMUTABLE_OPTION,
                null,
                InputOption::VALUE_NONE,
                'Generates immutable version of a manifest file',
            ),
            new InputOption(
                ManifestOptions::WORKING_DIR_OPTION,
                'd',
                InputOption::VALUE_REQUIRED,
                'If specified, use the given directory as working directory',
                null
            ),
        ];

        $this->setName(self::NAME)
            ->setDescription('Create a pipeline of your manifest build process.')
            ->setDefinition(
                new InputDefinition(
                    array_merge((new BoxHelper())->getBoxConfigOptions(), $options)
                )
            )
            ->setHelp(self::HELP)
        ;
    }

    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        /** @var DebugFormatterHelper $debugFormatter */
        $debugFormatter = $this->getHelper('debug_formatter');

        $logger = new Logger($debugFormatter, $output);

        $pid = uniqid();

        $startTime = microtime(true);

        /** @var BoxHelper $boxHelper */
        $boxHelper = $this->getHelper(BoxHelper::NAME);

        $io = new IO($input, $output);

        $options = new ManifestOptions($io);

        $resources = $io->getTypedOption(ManifestOptions::RESOURCE_OPTION)->asNonEmptyStringList();

        $bootstrap = $options->getBootstrap() ?? '';

        $resourceCount = count($resources);

        $stages = array_unique($io->getTypedArgument(ManifestOptions::STAGES_OPTION)->asNonEmptyStringList());

        $logger->notice(
            sprintf('Workflow with following stages >> %s', implode(', ', $stages)),
            ['status' => Logger::STATUS_STARTED, 'id' => $pid]
        );
        $context = ['status' => Logger::STATUS_STOPPED, 'id' => $pid, 'error' => false];

        // 1. (optional) but should be tried first before any other environment changes
        $bootstrap = realpath($bootstrap);

        if (is_string($bootstrap) && is_file($bootstrap)) {
            $logger->notice(
                sprintf('Bootstrapped file "%s"', $bootstrap),
                ['status' => Logger::STATUS_RUNNING, 'id' => $pid, 'prefix' => 'IN']
            );
            include $bootstrap;
        }

        // 2. (optional) changes current working directory
        try {
            $workingDir = $this->changeWorkingDir($options->getWorkingDir());
            if (null !== $workingDir) {
                $logger->notice(
                    sprintf('Changed working directory to "%s"', getcwd()),
                    ['status' => Logger::STATUS_RUNNING, 'id' => $pid, 'prefix' => 'IN']
                );
            }
        } catch (UnexpectedValueException $e) {
            $context['error'] = true;
            $logger->error($e->getMessage(), $context);
            $logger->error('Aborting workflow ... none operation was executed', $context);
            return Command::FAILURE;
        }

        // 3. creates the Pipeline with stages asked
        $pipelineBuilder = new PipelineBuilder();

        foreach ($stages as $stageName) {
            try {
                $arguments = [$io, $this, $logger, ['pid' => $pid]];
                $stage = match ($stageName) {
                    StageInterface::BUILD_STAGE => new BuildStage(...$arguments),
                    StageInterface::STUB_STAGE => new StubStage(...$arguments),
                    StageInterface::CONFIGURE_STAGE => new ConfigureStage(...$arguments),
                    StageInterface::COMPILE_STAGE => new CompileStage(...$arguments),
                    default => $this->getCustomStage($stageName, ...$arguments),
                };
            } catch (InvalidArgumentException $e) {
                $context['error'] = true;
                $logger->error($e->getMessage(), $context);
                $logger->error('Aborting workflow ... none operation was executed', $context);
                return Command::FAILURE;
            }

            $pipelineBuilder->add($stage);
        }

        $processor = $io->isDebug()
            ? new InterruptibleTimedProcessor($logger)
            : new FingersCrossedProcessor()
        ;
        $pipeline = $pipelineBuilder->build($processor);

        // 4. prepares payload to transmit to all stages of the pipeline
        $config = $boxHelper->getBoxConfiguration(
            $io->withOutput(new NullOutput()),
            true,
            $io->getTypedOption(BoxHelper::NO_CONFIG_OPTION)->asBoolean()
        );

        $makeOptions = new ManifestOptions($io);

        $templatePath = $makeOptions->getTemplateFile()
            ?? dirname(__DIR__, 3) . '/resources/default_stub.template'
        ;

        $payload = [
            'pid' => $pid,
            'configuration' => $config,
            'config' => $config->getConfigurationFile(),
            'ansiSupport' => $output->isDecorated(),
            'immutableCopy' => $io->getTypedOption(ManifestOptions::IMMUTABLE_OPTION)->asBoolean(),
            'versions' => [
                'box' => $boxHelper->getBoxVersion(),
                'boxManifest' => $this->getApplication()?->getVersion() ? : '@dev',
            ],
            'template' => $templatePath,
            'resources' => $resources,
            'map' => $config->getFileMapper()->getMap(),
            'resourceDir' => $makeOptions->getResourceDir(),
            'sbomSpec' => $makeOptions->getSbomSpec(),
            'outputFormat' => $makeOptions->getFormat(true),
            'output' => $makeOptions->getOutputFile() ?? 'php://stdout',
            'outputStub' => $makeOptions->getOutputStubFile(),
            'outputConf' => $makeOptions->getOutputConfFile(),
            'configurationFile' => $config->getConfigurationFile(),
        ];

        // 5. runs the workflow (pipeline)
        try {
            $pipeline($payload);
            $isSuccessful = true;
        } catch (Throwable $e) {
            $context['error'] = true;
            $logger->error('Workflow has failed', $context);
            $isSuccessful = false;
        } finally {
            if ($isSuccessful) {
                $logger->notice(
                    sprintf(
                        'Workflow has finished. Elapsed time %s',
                        Helper::formatTime(microtime(true) - $startTime)
                    ),
                    $context
                );
                return Command::SUCCESS;
            }
            return Command::FAILURE;
        }
    }

    private function changeWorkingDir(?string $newWorkingDir): ?string
    {
        if (null !== $newWorkingDir) {
            $oldWorkingDir = getcwd();
            if (false !== $oldWorkingDir && $newWorkingDir !== $oldWorkingDir) {
                if (false === chdir($newWorkingDir)) {
                    throw new UnexpectedValueException(
                        sprintf(
                            'Failed to change the working directory from "%s" to "%s".',
                            $oldWorkingDir,
                            $newWorkingDir,
                        )
                    );
                }
            }
        }
        return $newWorkingDir;
    }

    private function getCustomStage(string $stageClass, IO $io, Command $command, LoggerInterface $logger, array $context): StageInterface
    {
        if (!class_exists($stageClass)) {
            throw new InvalidArgumentException(
                sprintf('No stage found for "%s".', $stageClass)
            );
        }

        $stage = $stageClass::create($io, $command, $logger, $context);

        if (!$stage instanceof StageInterface) {
            throw new InvalidArgumentException(
                sprintf('Stage class "%s" does not implement "%s".', $stageClass, StageInterface::class)
            );
        }

        return $stage;
    }
}
