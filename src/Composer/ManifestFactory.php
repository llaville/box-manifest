<?php declare(strict_types=1);
/**
 * This file is part of the BoxManifest package.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace Bartlett\BoxManifest\Composer;

use Bartlett\BoxManifest\Composer\Manifest\DecorateTextManifestBuilder;
use Bartlett\BoxManifest\Composer\Manifest\SbomManifestBuilder;
use Bartlett\BoxManifest\Composer\Manifest\SimpleTextManifestBuilder;

use CycloneDX\Core\Serialization\DOM\NormalizerFactory as DomNormalizerFactory;
use CycloneDX\Core\Serialization\JSON\NormalizerFactory as JsonNormalizerFactory;
use CycloneDX\Core\Serialization\JsonSerializer;
use CycloneDX\Core\Serialization\XmlSerializer;
use CycloneDX\Core\Spec\SpecFactory;

use KevinGH\Box\Box;
use KevinGH\Box\Configuration\Configuration;
use function KevinGH\Box\FileSystem\make_path_absolute;

use InvalidArgumentException;
use function array_key_exists;
use function class_exists;
use function file_exists;
use function file_get_contents;
use function implode;
use function is_readable;
use function is_string;
use function pathinfo;
use function realpath;
use const PATHINFO_EXTENSION;

/**
 * @author Laurent Laville
 */
final class ManifestFactory
{
    public function __construct(private Configuration $config, private Box $box, private string $boxVersion)
    {
    }

    public function build(string $format, ?string $output): string
    {
        return match ($format) {
            'auto' => match ($output) {
                null, 'manifest.txt' => $this->toText(),
                'sbom.xml' => $this->toSbomXml1dot3(),
                'sbom.json' => $this->toSbomJson1dot3(),
                default => match (pathinfo($output, PATHINFO_EXTENSION)) {
                    'xml' => $this->toSbomXml1dot3(),
                    'json' => $this->toSbomJson1dot3(),
                    '', 'txt' => $this->toText(),
                }
            },
            'plain' => $this->toText(),
            'ansi' => $this->toHighlight(),
            'sbom' => $this->toSbomJson1dot3(),
            default => class_exists($format)
                ? self::create($format, $this->config, $this->box)
                : throw new InvalidArgumentException(sprintf('Format "%s" is not supported', $format))
        };
    }

    /**
     * Search for manifest files ('manifest.txt', 'sbom.xml', 'sbom.json') generated by the `contrib:add-manifest` command.
     *
     * This function is useful to include manifest contents as a `metadata` contents of PHP Archive.
     * E.g:
     * ```json
     *     "metadata": "Bartlett\\BoxManifest\\Composer\\ManifestFactory::get"
     * ```
     *
     * @link https://github.com/box-project/box/blob/main/doc/configuration.md#metadata-metadata
     */
    public static function get(): ?string
    {
        foreach (['manifest.txt', 'sbom.xml', 'sbom.json'] as $resource) {
            $resolved = realpath($resource) ?: (file_exists($resource) ? $resource : null);
            if ($resolved) {
                return file_get_contents($resolved);
            }
        }
        return null;
    }

    public static function create(string|object $from, Configuration $config, Box $box): ?string
    {
        if (is_string($from)) {
            if (!class_exists($from)) {
                // Class provided does not exist, or is not readable by Composer Autoloader
                return null;
            }
            $builder = new $from();
        } else {
            $builder = $from;
        }

        if (!$builder instanceof ManifestBuilderInterface) {
            // Your manifest class builder is not compatible.
            return null;
        }

        // The composer.lock and installed.php are optional (e.g. if there is no dependencies installed)
        // but when one is present, the other must be as well
        $composerLock = $config->getComposerLock();
        if (null === $composerLock) {
            // No dependencies installed
            return null;
        }

        $decodedJsonContents = $config->getDecodedComposerJsonContents();

        $normalizePath = function ($file, $basePath) {
            return make_path_absolute(trim($file), $basePath);
        };

        $basePath = $config->getBasePath();

        if (null !== $decodedJsonContents && array_key_exists('vendor-dir', $decodedJsonContents)) {
            $vendorDir = $normalizePath($decodedJsonContents['vendor-dir'], $basePath);
        } else {
            $vendorDir = $normalizePath('vendor', $basePath);
        }

        $file = implode(DIRECTORY_SEPARATOR, [$vendorDir, 'composer', 'installed.php']);
        if (!file_exists($file) || !is_readable($file)) {
            return null;
        }
        $installedPhp = include $file;

        return $builder(
            [
                'composer.json' => $decodedJsonContents,
                'composer.lock' => $config->getDecodedComposerLockContents(),
                'installed.php' => (array) $installedPhp,
            ]
        );
    }

    public function toText(): ?string
    {
        return self::create(SimpleTextManifestBuilder::class, $this->config, $this->box);
    }

    public function toHighlight(): ?string
    {
        return self::create(new DecorateTextManifestBuilder(), $this->config, $this->box);
    }

    public function toSbomXml1dot3(): ?string
    {
        $xmlSerializer = new XmlSerializer(new DomNormalizerFactory(SpecFactory::make1dot3()));
        return self::create(new SbomManifestBuilder($xmlSerializer, $this->boxVersion), $this->config, $this->box);
    }

    public function toSbomJson1dot3(): ?string
    {
        $jsonSerializer = new JsonSerializer(new JsonNormalizerFactory(SpecFactory::make1dot3()));
        return self::create(new SbomManifestBuilder($jsonSerializer, $this->boxVersion), $this->config, $this->box);
    }
}
